// Include the necessary libraries
#include <NewPing.h>
#include <Servo.h>
#include <AFMotor.h>
#include <SoftwareSerial.h> // Include SoftwareSerial library for Bluetooth communication

// Definitions for pins and sensor parameters
#define RIGHT A5
#define LEFT A3
#define TRIGGER_PIN A1
#define ECHO_PIN A0
#define MAX_DISTANCE 200

// Definitions for Bluetooth communication
#define bluetoothTx 0 // TX pin of Bluetooth module connected to digital pin 0 (RX of Arduino)
#define bluetoothRx 1 // RX pin of Bluetooth module connected to digital pin 1 (TX of Arduino)
SoftwareSerial bluetooth(bluetoothTx, bluetoothRx);

// Global variables
unsigned int distance = 0;
unsigned int Right_Value = 0;
unsigned int Left_Value = 0;

// Objects initialization
NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE);
AF_DCMotor Motor1(1, MOTOR12_1KHZ);
AF_DCMotor Motor2(2, MOTOR12_1KHZ);
AF_DCMotor Motor3(3, MOTOR34_1KHZ);
AF_DCMotor Motor4(4, MOTOR34_1KHZ);
Servo myservo;
int pos = 0;

void setup() {
  // Initialize serial communication for debugging
  Serial.begin(9600);

  // Initialize Bluetooth communication
  bluetooth.begin(9600);

  // Initialize servo
  myservo.attach(10);
  servoCalibration(); // Perform servo calibration

  // Set pins as inputs
  pinMode(RIGHT, INPUT);
  pinMode(LEFT, INPUT);
}

// Define a flag variable to track whether autonomous mode should continue
bool autonomousModeActive = true;

void loop() {
  // Check if autonomous mode is active and there's no Bluetooth command
  if (autonomousModeActive && !bluetooth.available()) {
    // Continue with autonomous mode
    autonomousMode();
  } else if (bluetooth.available()) {
    // If Bluetooth command is available
    char command = bluetooth.read();
    handleBluetoothCommand(command);
    // Disable autonomous mode
    autonomousModeActive = false;
  }
}

// Function to handle Bluetooth commands
void handleBluetoothCommand(char command) {
  switch (command) {
    case 'F': // Forward command
      moveForward();
      break;
    case 'L': // Left command
      turnLeft();
      break;
    case 'R': // Right command
      turnRight();
      break;
    case 'T': // Stop command
      stopMotors();
      break;
    default:
      break;
  }
}

// Function to handle autonomous mode
void autonomousMode() {
  // Read sensor values
  delay(50);
  distance = sonar.ping_cm();
  Right_Value = digitalRead(RIGHT);
  Left_Value = digitalRead(LEFT);

  // Print sensor values for debugging
  Serial.print("distance");
  Serial.println(distance);
  Serial.print("RIGHT");
  Serial.println(Right_Value);
  Serial.print("LEFT");
  Serial.println(Left_Value);

  // Autonomous control based on sensor readings
  if (distance > 40) {
    moveForward();
  } else if (Right_Value == 1 && Left_Value == 0) {
    turnLeft();
    delay(150);
  } else if (Right_Value == 0 && Left_Value == 1) {
    turnRight();
    delay(150);
  } else if (distance < 15) {
    stopMotors();
  }
}

// Function to move forward
void moveForward() {
  Motor1.setSpeed(130);
  Motor1.run(FORWARD);
  Motor2.setSpeed(130);
  Motor2.run(FORWARD);
  Motor3.setSpeed(130);
  Motor3.run(FORWARD);
  Motor4.setSpeed(130);
  Motor4.run(FORWARD);
}

// Function to turn left
void turnLeft() {
  Motor1.setSpeed(150);
  Motor1.run(FORWARD);
  Motor2.setSpeed(150);
  Motor2.run(FORWARD);
  Motor3.setSpeed(150);
  Motor3.run(BACKWARD);
  Motor4.setSpeed(150);
  Motor4.run(BACKWARD);
}

// Function to turn right
void turnRight() {
  Motor1.setSpeed(150);
  Motor1.run(BACKWARD);
  Motor2.setSpeed(150);
  Motor2.run(BACKWARD);
  Motor3.setSpeed(150);
  Motor3.run(FORWARD);
  Motor4.setSpeed(150);
  Motor4.run(FORWARD);
}

// Function to stop motors
void stopMotors() {
  Motor1.setSpeed(0);
  Motor1.run(RELEASE);
  Motor2.setSpeed(0);
  Motor2.run(RELEASE);
  Motor3.setSpeed(0);
  Motor3.run(RELEASE);
  Motor4.setSpeed(0);
  Motor4.run(RELEASE);
}

// Function to calibrate servo
void servoCalibration() {
  for (pos = 90; pos <= 150; pos += 1) {
    myservo.write(pos);
    delay(15);
  }
  for (pos = 150; pos >= 30; pos -= 1) {
    myservo.write(pos);
    delay(15);
  }
  for (pos = 30; pos <= 90; pos += 1) {
    myservo.write(pos);
    delay(15);
  }
}
